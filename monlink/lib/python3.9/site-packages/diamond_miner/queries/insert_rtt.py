from dataclasses import dataclass

from diamond_miner.defaults import UNIVERSE_SUBSET
from diamond_miner.queries.query import Query, rtt_table, results_table, far_end_table, conjest_table
from diamond_miner.typing import IPNetwork

from dataclasses import field


def rttQuery( measurement_id: str, round_: int):
    return f"""
        SELECT 
            probe_dst_addr,
            probe_src_port,
            probe_ttl,
            length(groupArray(rtt)) as recv_cnt, 
            arraySort(groupArray(rtt))[CAST(ceil(recv_cnt/2) AS int)] as median_rtt,
            length(groupUniqArray(reply_src_addr)) as reply_src_cnt,
            round
        FROM {far_end_table(measurement_id)}
        LEFT JOIN {results_table(measurement_id)}
        USING probe_dst_addr, probe_src_port, probe_ttl
        WHERE round = {round_}
        GROUP BY probe_dst_addr, probe_src_port, probe_ttl, round
    """ 

@dataclass(frozen=True)
class InsertRtt(Query):

    round_: int = field(default=1)

    def statement(
        self, measurement_id: str, subset: IPNetwork = UNIVERSE_SUBSET
    ) -> str:
        return f"""
            INSERT INTO {rtt_table(measurement_id)}
            {rttQuery(measurement_id, self.round_)}
         """

@dataclass(frozen=True)
class InsertConjest(Query):

    round_: int = field(default=1)

    def statement_insert(
        self, measurement_id: str, subset: IPNetwork = UNIVERSE_SUBSET
    ) -> str:
        # return f"""
            # WITH {self.round_} AS cur_round
        #     , min_latency AS (
        #         SELECT 
        #             probe_dst_addr, 
        #             probe_src_port, 
        #             probe_ttl, 
        #             min(rtt) as min_rtt
        #         FROM {far_end_table(measurement_id)}
        #         LEFT JOIN {results_table(measurement_id)}
        #         USING probe_dst_addr, probe_src_port, probe_ttl
        #         GROUP BY probe_dst_addr, probe_src_port, probe_ttl
        #     )
        #     , min_median_latency AS (
        #         SELECT 
        #             probe_dst_addr, 
        #             probe_src_port, 
        #             probe_ttl, 
        #             min(median_rtt) as min_rtt
        #         FROM {rtt_table(measurement_id)}
        #         GROUP BY probe_dst_addr, probe_src_port, probe_ttl
        #     )
        #     SELECT 
        #         probe_dst_addr, 
        #         probe_src_port,  
        #         median_rtt-min_median_latency.min_rtt as inflation 
        #     FROM {rtt_table(measurement_id)}
        #     LEFT JOIN min_median_latency
        #     USING probe_dst_addr, probe_src_port, probe_ttl
        #     WHERE round=cur_round AND median_rtt<4000 AND recv_cnt>5 AND median_rtt>10 AND inflation>100
        # """
        return f"""
        INSERT INTO {conjest_table(measurement_id)}
        WITH 
        {self.round_} AS cur_round
        , rtt_cur AS (
            SELECT * FROM {rtt_table(measurement_id)}
            WHERE round=cur_round AND reply_src_cnt=1
        )        
        , rtt_last AS (
            SELECT * FROM {rtt_table(measurement_id)}
            WHERE round=cur_round-1 AND reply_src_cnt=1
        )
        SELECT 
            now() as timestamp,
            probe_dst_addr, 
            probe_src_port,  
            probe_ttl,
            rtt1.median_rtt-rtt2.median_rtt as fluctuation,
            {self.round_} as round
        FROM rtt_cur rtt1
        JOIN rtt_last rtt2
        USING probe_dst_addr, probe_src_port, probe_ttl
        WHERE (rtt1.median_rtt-rtt2.median_rtt > rtt1.median_rtt*0.15 OR rtt2.median_rtt-rtt1.median_rtt > rtt2.median_rtt*0.15) 
        """
    def statement_query(
        self, measurement_id: str, subset: IPNetwork = UNIVERSE_SUBSET
    ) -> str:
        return f"""
        SELECT * FROM {conjest_table(measurement_id)}
        WHERE round={self.round_}
        """