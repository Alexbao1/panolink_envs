from dataclasses import dataclass

from diamond_miner.defaults import UNIVERSE_SUBSET
from diamond_miner.queries.query import Query, rtt_table, results_table, far_end_table, conjest_table, rtt_std_table
from diamond_miner.typing import IPNetwork

from dataclasses import field


def rttQuery( measurement_id: str, round_: int):
    return f"""
        SELECT 
            probe_dst_addr,
            probe_src_port,
            probe_ttl,
            length(groupArray(rtt)) as recv_cnt, 
            arraySort(groupArray(rtt))[CAST(ceil(recv_cnt/2) AS int)] as median_rtt,
            length(groupUniqArray(reply_src_addr)) as reply_src_cnt,
            round
        FROM {far_end_table(measurement_id)}
        LEFT JOIN {results_table(measurement_id)}
        USING probe_dst_addr, probe_src_port, probe_ttl
        WHERE round = {round_}
        GROUP BY probe_dst_addr, probe_src_port, probe_ttl, round
    """ 

@dataclass(frozen=True)
class InsertRtt(Query):

    round_: int = field(default=1)

    def statement(
        self, measurement_id: str, subset: IPNetwork = UNIVERSE_SUBSET
    ) -> str:
        return f"""
            INSERT INTO {rtt_table(measurement_id)}
            {rttQuery(measurement_id, self.round_)}
         """

@dataclass(frozen=True)
class InsertConjest(Query):

    round_: int = field(default=1)
    std_threshold: int = field(default=70)
    min_fault_round: int = field(default=10)
    def statement_insert(
        self, measurement_id: str, subset: IPNetwork = UNIVERSE_SUBSET
    ) -> str:
        return f"""
        INSERT INTO {conjest_table(measurement_id)}
        WITH 
        {self.round_} AS cur_round
        , rtt_cur AS (
            SELECT * FROM {rtt_table(measurement_id)}
            WHERE round=cur_round
        )  
        , rtt_last AS (
            SELECT * FROM {rtt_table(measurement_id)}
            WHERE round=cur_round-1
        )       
        SELECT 
            now() as timestamp,
            probe_dst_addr, 
            probe_src_port,  
            probe_ttl,
            rtt1.median_rtt-rtt2.median_rtt as fluctuation,
            {self.round_} as round
        FROM rtt_cur rtt1
        JOIN rtt_last rtt2
        USING probe_dst_addr, probe_src_port, probe_ttl
        WHERE (rtt1.median_rtt-rtt2.median_rtt > rtt1.median_rtt*0.15 OR rtt2.median_rtt-rtt1.median_rtt > rtt2.median_rtt*0.15) 
        """



    def statement_query(
        self, measurement_id: str, subset: IPNetwork = UNIVERSE_SUBSET
    ) -> str:
        return f"""
        SELECT * FROM {conjest_table(measurement_id)}
        WHERE round={self.round_}
        """



    def statement_test_insert(
        self, measurement_id: str, subset: IPNetwork = UNIVERSE_SUBSET
    ) -> str:
        return f"""
        INSERT INTO {rtt_std_table(measurement_id)}
        WITH 
        {self.round_} AS cur_round
        SELECT 
            probe_dst_addr, 
            probe_src_port, 
            probe_ttl, 
            stddevPop(median_rtt) as rtt_std, 
            cur_round as round_test
        FROM {rtt_table(measurement_id)} t1
        WHERE t1.round<=cur_round AND t1.round+{self.min_fault_round} >= cur_round+1
        GROUP BY probe_dst_addr, probe_src_port, probe_ttl
        """

    def statement_test_suspect_query(
        self, measurement_id: str, subset: IPNetwork = UNIVERSE_SUBSET
    ) -> str:
        return f"""
        WITH
        {self.round_} AS cur_round
        SELECT probe_dst_addr, probe_src_port FROM (
            SELECT probe_dst_addr, probe_src_port, min(rtt_std) as min_rtt_std FROM {rtt_std_table(measurement_id)}
            WHERE round_test <= cur_round AND round_test+{self.min_fault_round} >= cur_round+1
            GROUP BY probe_dst_addr, probe_src_port
        )
        WHERE min_rtt_std > {self.std_threshold}
        """

    def statement_test_innocent_query(
        self, measurement_id: str, subset: IPNetwork = UNIVERSE_SUBSET
    ) -> str:
        return f"""
        WITH
        {self.round_} AS cur_round
        SELECT probe_dst_addr, probe_src_port FROM (
            SELECT probe_dst_addr, probe_src_port, max(rtt_std) as max_rtt_std FROM {rtt_std_table(measurement_id)}
            WHERE round_test <= cur_round AND round_test+{self.min_fault_round} >= cur_round+1
            GROUP BY probe_dst_addr, probe_src_port
        )
        WHERE max_rtt_std <= {self.std_threshold/3}
        """